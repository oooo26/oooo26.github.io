<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R语言小记 | 安装R包</title>
      <link href="/2022/04/16/tutorial-install-r-package/"/>
      <url>/2022/04/16/tutorial-install-r-package/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近两个月写毕业论文去了，鸽了。现在重新开更，一时间也想不出要水点什么，就写一下之前遇到的一个R包安装的小问题吧。</p></blockquote><h2 id="一般安装">一般安装</h2><p>不同于其他语言，R有着高度集权的管理体系，至少我目前遇到的几乎所有包都要在<a href="https://cran.r-project.org/web/packages/index.html">cran</a>上找（当然也有从源码安装），并且R语言的IDE基本等价于<a href="https://www.rstudio.com/">Rstudio</a>（其他都不够好用）。<br>文档虽然有很多换皮网站，比如<a href="https://www.rdocumentation.org/">Rdocument</a>和<a href="https://rdrr.io/">Rdrr</a>，但其内容都是从cran的包简介里面扒的。咳咳，扯远了。。</p><p>总而言之，我一直认为R包的安装都是统一的：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> install.packages<span class="punctuation">(</span><span class="string">&quot;&#123;PACKAGE_NAME&#125;&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>最多就是加入了一些参数：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装包及其依赖项</span></span><br><span class="line"><span class="operator">&gt;</span> install.packages<span class="punctuation">(</span><span class="string">&quot;&#123;PACKAGE_NAME&#125;&quot;</span><span class="punctuation">,</span> dependencies<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>而一般的包确实如此，所以安装流程很懒人：</p><ol><li>搜索cran上有没有这个包</li><li>用<code>install.packages</code>安装</li></ol><h2 id="特殊情况（以pcalg为例）">特殊情况（以pcalg为例）</h2><p>然而，从来如此，便对么？<br>最近我才发现，R包<s>居然</s>确实可以不由cran提供！以<a href="https://cran.r-project.org/web/packages/pcalg/">pcalg</a>为例：</p><p><img src="/img/install_r_pkg1.png" alt=""></p><p><strong>Imports</strong>部分就是其所依赖的部件，而<strong>Suggests</strong>部分是可选安装的依赖。更具体的：</p><ul><li>黑色无链接：表示R语言内置包</li><li>蓝色有链接：表示cran上的包，可以通过<code>dependencies=T</code>来安装</li><li>青色有链接：表示其他平台的包，需要自行安装</li></ul><p>因此，为了安装这样的包，我们需要一个个点进青色链接来手动安装依赖。以上面为例，<br><code>graph</code>链接点进去是<a href="http://www.bioconductor.org/packages/release/bioc/html/graph.html">这个网站</a>，它来自这个叫BiocManager的库。</p><blockquote><p>从第三方库安装，需要仔细查看安装说明。比如BiocManager对于R版本4.1以上/以下具有不同的安装方法。</p></blockquote><p>如果不闻不问，只是一个劲的用<code>install.packages('pcalg')</code>装，那结果只能是一直报错，然后心态大崩。。<br>（<s>鲁迅先生说得好呀</s>）</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> r </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++/Python联合编译：pybind11</title>
      <link href="/2022/02/16/tutorial-pybind/"/>
      <url>/2022/02/16/tutorial-pybind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Python方便但效率低，C++效率高但不方便，那不如把他们合起来用？<br>本篇介绍Python作为API、C++作为底层实现的方式之一：pybind11.</p></blockquote><p>想要联合编译Python和C++有很多种方法和工具，我目前在用的是<a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11</a>，给我感觉挺方便好用的。</p><h2 id="安装pybind11">安装pybind11</h2><p>对于Linux来说，如果官方源里面有的话，可以直接从官方源安装，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S pybind11</span><br></pre></td></tr></table></figure><p>否则可以根据<a href="https://pybind11.readthedocs.io/en/stable/installing.html">官方文档</a>安装，但强烈不建议PyPI里的包（功能不完全）！</p><p>再退一步，不装也没关系，直接把它源码从<a href="https://github.com/pybind/pybind11">Github仓库</a>扒下来，后面会讲到要怎么用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/pybind/pybind11.git</span><br></pre></td></tr></table></figure><h2 id="联合编译">联合编译</h2><h3 id="方式一：setuptools-link">方式一：setuptools <a href="https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-setuptools">[link]</a></h3><p>这种方式相对传统（但常用），利用的是Python的打包工具setuptools（一般默认装了），可以利用pip进行管理。</p><p>示例目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pyproject.toml</span><br><span class="line">├── setup.py</span><br><span class="line">└── src</span><br><span class="line">    ├── bind.cpp</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><ul><li><code>main.cpp</code>是实现代码；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br></pre></td></tr></table></figure></li><li><code>bind.cpp</code>是接口函数，记录需要编译哪些代码；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example是项目名，即“import example“</span></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(example, m) &#123;</span><br><span class="line">    <span class="comment">// def是项目内的函数声明：</span></span><br><span class="line">    <span class="comment">//     参数一是函数名，即“example.add(i, j)”</span></span><br><span class="line">    <span class="comment">//     参数二是对应C++函数的指针</span></span><br><span class="line">    <span class="comment">//     参数三是函数说明，即docstring</span></span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add&quot;</span>, &amp;add, <span class="string">&quot;A function that adds two numbers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>setup.py</code>和<code>pyproject.toml</code>是setuptools的安装配置文件；  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> pybind11.setup_helpers <span class="keyword">import</span> Pybind11Extension</span><br><span class="line"></span><br><span class="line"><span class="comment"># module</span></span><br><span class="line">ext_modules = [</span><br><span class="line">    Pybind11Extension(</span><br><span class="line">        <span class="string">&quot;example&quot;</span>,          <span class="comment"># 包名</span></span><br><span class="line">        [<span class="string">&quot;src/bind.cpp&quot;</span>]    <span class="comment"># 接口文件</span></span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&quot;example&quot;</span>,         <span class="comment"># 包名（和上面一样）</span></span><br><span class="line">    ext_modules=ext_modules,</span><br><span class="line">    python_requires=<span class="string">&quot;&gt;=3.6&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [    <span class="comment"># 依赖包</span></span><br><span class="line">    <span class="string">&quot;setuptools&gt;=42&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wheel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pybind11~=2.6.1&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">&quot;setuptools.build_meta&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>准备完成后，可以在项目目录里面进行本地装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install . --user</span><br></pre></td></tr></table></figure><p>显示安装成功即可在Python里面使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> example</span><br><span class="line">example.add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="方式二：cmake-link">方式二：cmake <a href="https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake">[link]</a></h3><p>第二种方式是利用cmake编译出一个单独的项目<code>.so</code>，不用装包，比较轻便化。<br>如果没装<a href="https://cmake.org/download/">cmake</a>的话需要先装好。</p><p>示例目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── bind.cpp</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如前面并没有安装pybind11，而是使用Github源码，则同样要放进目录里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pybind11</span><br><span class="line">│   └── ...</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── bind.cpp</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>src</code>文件夹里的是C++实现代码，和上面说的一样；</li><li><code>CMakeLists.txt</code>（名称不可变）是cmake的配置文件。  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># cmake最低版本限制，实际上不写也行</span><br><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line"></span><br><span class="line"># 项目名</span><br><span class="line">project(example)</span><br><span class="line"></span><br><span class="line"># 导入pybind</span><br><span class="line"># add_subdirectory(pybind11) # 假如使用pybind11本地源码，则写这行，否则写下面那行</span><br><span class="line">find_package(pybind11)</span><br><span class="line"></span><br><span class="line"># 导入接口文件</span><br><span class="line">pybind11_add_module(example src/bind.cpp)</span><br></pre></td></tr></table></figure></li></ul><p>准备好后，创建一个新文件夹来存放编译文件（为了不混乱）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..          <span class="comment"># 创建可编译文件</span></span><br><span class="line">$ cmake --build .   <span class="comment"># 编译，相当于`make`命令</span></span><br></pre></td></tr></table></figure><blockquote><p>假如出现这个错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By not providing <span class="string">&quot;Findpybind11.cmake&quot;</span> <span class="keyword">in</span> CMAKE_MODULE_PATH this project has</span><br><span class="line">asked CMake to find a package configuration file provided by <span class="string">&quot;pybind11&quot;</span>,</span><br><span class="line">but CMake did not find one.</span><br></pre></td></tr></table></figure><p>那就是因为pybind安装不完全（可能是使用了PyPI包），需要用别的方法装完整版或者扒Github源码。</p></blockquote><p>一切顺利的话应该会达到进度100%：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 50%] Building CXX object CMakeFiles/example.dir/bind.cpp.o</span><br><span class="line">[100%] Linking CXX shared module example.cpython-310-x86_64-linux-gnu.so</span><br><span class="line">[100%] Built target example</span><br></pre></td></tr></table></figure><p>然后它在<code>build</code>文件夹里面创建的那个<code>example.*.so</code>就是转码后文件，可以把他复制到你想要用的任何地方，在Python里面导入就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> example</span><br><span class="line">example.add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这种方法并没有安装包，所以没有了那个<code>example.*.so</code>文件就会失败。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch折腾记 | 安装Windows/Arch双系统（二）</title>
      <link href="/2022/01/24/tutorial-archinstall-2/"/>
      <url>/2022/01/24/tutorial-archinstall-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>终于要整图形化界面啦！</p></blockquote><a href="/2022/01/23/tutorial-archinstall-1/" title="上回">上回</a>说到，我们已经成功安装了Arch Linux到硬盘里，但它仍然处于黑框命令行的形式，想作为日常使用的机子显然是不够的，再怎么说也得整个图形界面出来吧。<h2 id="写在最前">写在最前</h2><p>配置图形界面，难免可能写错配置文件，这有可能导致进入图形界面后卡死，但又因为没法进入命令行而无法修复。因此建议：</p><ol><li>在全部配置完成之前，<strong>不要</strong>打开图形界面的自启动，以免出了问题也进不了命令行；</li><li>假如打开了图形界面自启，卡死了，也不用慌。重新插入启动盘，从启动盘进入系统，挂载分区，并通过<code>arch-chroot</code>进入命令行进行修复；</li></ol><h2 id="选择图形界面">选择图形界面</h2><p>图形界面有<a href="https://wiki.archlinux.org/title/desktop_environment">很多选择</a>，我这里介绍的是<a href="https://wiki.archlinux.org/title/KDE#Plasma">KDE Plasma</a>，其他的界面配置就请自行查看wiki了。</p><p>首先需要安装xorg依赖包，以及显卡驱动，具体请看<a href="https://wiki.archlinux.org/title/Xorg">这个说明</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S xorg-server xf86-video-intel mesa lib32-mesa</span><br></pre></td></tr></table></figure><blockquote><p>最后一个<code>lib32-mesa</code>包可能会找不到，需要启用multilib仓库：在<code>/etc/pacman.conf</code>里面找到如下行，并取消前面的注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>然后<code>sudo pacman -Syu</code>更新一下仓库即可。</p></blockquote><p>现在可以安装KDE Plasma了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S plasma</span><br></pre></td></tr></table></figure><p>假如需要开箱即用，也可以顺便安装KDE提供的全套工具包（<s>全家桶</s>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S  kde-applications</span><br></pre></td></tr></table></figure><p>耗时挺长的。。喝杯茶去。。</p><h2 id="进入图形界面">进入图形界面</h2><p>界面装好了，但怎么告诉Arch我想通过图形界面进来呢？这就需要有个<a href="https://wiki.archlinux.org/title/Display_manager">管理器</a>。</p><blockquote><p>此外，假如安装了多种图形化界面，在不同界面之间切换也是通过管理器。</p></blockquote><p>官方推荐的管理器是<a href="https://wiki.archlinux.org/title/SDDM">SDDM</a>，那我就只介绍这一个吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S sddm </span><br></pre></td></tr></table></figure><p>对于KDE桌面，还推荐安装一个模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S sddm-kcm</span><br></pre></td></tr></table></figure><blockquote><p>如果没装KDE全家桶地同学<strong>强烈建议</strong>先不要进图形化界面，至少看<a href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7">基本工具</a>部分装一下命令行哈~</p></blockquote><p>进入图形化界面！！！灯灯灯等~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start sddm</span><br></pre></td></tr></table></figure><h2 id="基本工具">基本工具</h2><p>杂七杂八的各种软件在<a href="https://wiki.archlinux.org/title/list_of_applications">这里</a>任君选择~</p><h3 id="命令行-link">命令行 <a href="https://wiki.archlinux.org/title/list_of_applications#Terminal">[link]</a></h3><p>我装的是Yakuake，一个下拉式的快捷命令行，按F12快捷呼出还不错。</p><h3 id="文件管理器-link">文件管理器 <a href="https://wiki.archlinux.org/title/list_of_applications#File_managers">[link]</a></h3><p>虽然颜值都不是很高，但感觉Dolphin还行，它也是KDE全家桶的内置文件管理器。</p><h3 id="图片浏览器-link">图片浏览器 <a href="https://wiki.archlinux.org/title/list_of_applications#Image">[link]</a></h3><p>这里我用的是Geeqie，纯粹因为支持的格式比较多。</p><h3 id="音频视频播放器-link">音频视频播放器 <a href="https://wiki.archlinux.org/title/list_of_applications#Video">[link]</a></h3><p>视频音频一般都会同时支持，这里就一起写了。<br>我用的是著名的VLC，同样因为支持的格式很多。</p><h3 id="网络管理器-link">网络管理器 <a href="https://wiki.archlinux.org/title/list_of_applications#Network_managers">[link]</a></h3><p>预装的网络管理器systemd-networkd没有图形化界面，虽然这没什么大不了，反正也可以通过命令行连接网络。但都搞图形化了，不如就换一个吧。</p><p>这里我用NetworkManager，他有两个<a href="https://wiki.archlinux.org/title/NetworkManager#Additional_interfaces">可选插件</a>也可以装一装，一个提供图形化网络配置界面，一个提供工具栏图标显示。</p><h3 id="网络浏览器-link">网络浏览器 <a href="https://wiki.archlinux.org/title/list_of_applications#Web_browsers">[link]</a></h3><p>我别的平台主要用Chrome，为了方便同步书签，用的是AUR包<a href="https://aur.archlinux.org/packages/google-chrome/">google-chrome</a>（因为官方源里的Chromium不支持用户登录）。AUR的安装我以后可能还会<s>挖个坑</s>写一篇。</p><h3 id="梯子-link">梯子 <a href="https://wiki.archlinux.org/title/list_of_applications#Proxy_servers">[link]</a></h3><p>这里我用的是Clash，具体看<a href="/2022/01/03/tutorial-clash/" title="这篇文章">这篇文章</a>的吧。</p><p>搭好之后可以到设置的proxy选项卡里选择手动设置地址，但有些程序可能不会自动从设置里找，就得去查查对应的解决方法了。</p><blockquote><p>顺便记录一下Chrome的设置：<br>安装好Chrome之后，他显示了这么一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==&gt; NOTE: Custom flags should be put directly <span class="keyword">in</span>: ~/.config/chrome-flags.conf</span><br></pre></td></tr></table></figure><p>由于Chrome的设置里面并不能找到端口设置，因此如果要科学上网，根据提示在<code>~/.config/chrome-flags.conf</code>里面加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--proxy-server=YOUR_PROXY</span><br></pre></td></tr></table></figure><p>保存即可，以后打开Chrome的时候就是用对应端口了。</p></blockquote><h2 id="设置杂项">设置杂项</h2><h3 id="蓝牙">蓝牙</h3><p>蓝牙并没有默认开启，所以如果有需求的话需要启动服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start bluetooth</span><br></pre></td></tr></table></figure><p>然后在设置里面就能添加蓝牙设备了。</p><h3 id="触控板">触控板</h3><p>触控板设置（可以在设置里面找到）默认可能没开启“点击”功能，需要自行开启；此外，双指滑动方向默认与Windows相反（与Mac类似），也可以在设置里面反转。</p><p><s>你试过没带有线鼠标只能靠着上/下/左/右/TAB/SPACE在设置里打开了触控板点击的辛酸历程吗淦</s></p><h3 id="中文显示">中文显示</h3><p>首先是字体的问题（可以打开百度看一眼），现在的系统上还没有中文字体包，所以有乱码。可以看<a href="https://wiki.archlinux.org/title/Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%AD%E6%96%87%E5%AD%97%E4%BD%93">这里</a>下载字体包，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure><p>然后是界面，由于之前安装的时候，我们设置了全局语言为<code>en_US.UTF-8</code>，因此现在的界面语言是英文。</p><blockquote><p>假如想要中文界面的话，根据<a href="https://wiki.archlinux.org/title/Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%BA%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87_locale">官方建议</a>，我们不要在全局语言中加入中文，但可以仅对当前用户修改，例如在<code>~/.xprofile</code>里面加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LANG=zh_CN.UTF-8</span><br><span class="line">export LANGUAGE=zh_CN:en_US</span><br></pre></td></tr></table></figure></blockquote><h3 id="输入法">输入法</h3><p>我们目前还没装输入法，这里我比较推荐<a href="https://wiki.archlinux.org/title/Fcitx5">fcitx5</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S fcitx5-im  fcitx5-configtool</span><br></pre></td></tr></table></figure><p>以及中文语言包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S fcitx5-chinese-addons</span><br></pre></td></tr></table></figure><p>再在<code>~/.xprofile</code>写入这几行（注意这里没有5）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure><p>这样重启后就可以使用fcitx5了（右下角有个小键盘标志，右键可以找到语言设置）。</p><h3 id="双系统时间同步">双系统时间同步</h3><p>假如装Windows和Linux双系统，很可能会出现两者时间不同步的情况。</p><blockquote><p>这是因为两者对硬件内存储时间的定义不一样：</p><ul><li>对Windows来说，硬件时间就是当地时间，不用换算；</li><li>对Linux来说，硬件时间是UTC-0，需要换算成当地时间；</li></ul><p>例如，在国内，Linux系统的时间会比Windows快8小时。</p></blockquote><p>显然，让时间同步有两种选择：</p><ul><li><p>让Windows用Linux的时间定义：</p><p>在Windows下启动管理员模式的Powershell，输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot;</span> /v RealTimeIsUniversal /d <span class="number">1</span> /t REG_DWORD /f</span><br></pre></td></tr></table></figure></li><li><p>让Linux用Windows的时间定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo timedatectl set-local-rtc 1</span><br></pre></td></tr></table></figure></li></ul><p>哪个方便用哪个就好。</p><h2 id="自启动图形界面">自启动图形界面</h2><p><strong>！！！千万要保证手动启动没问题才开，以免卡死！！！</strong></p><p>最后需要让Arch开机自动进入图形界面，换句话说就是要自启动图形界面管理器（如SDDM），其他的功能模块也可以考虑自启动。<br>这个方法有很多，我主要使用<a href="https://wiki.archlinux.org/title/Systemd">systemd</a>来控制，例如：</p><ul><li>图形化界面：<code>$ sudo systemctl enable sddm</code>；</li><li>网络管理器：<code>$ sudo systemctl enable NetworkManager</code>；</li><li>蓝牙：<code>$ sudo systemctl enable bluetooth</code>；</li><li>…</li></ul><p>但也有些程序并没有提供<code>.service</code>文件，从而不能用上面的命令。除了自己写一个之外，也可以换个方法：在<code>~/.xprofile</code>里面加上开机后所需要运行的命令：</p><ul><li>命令行：<code>yakuake &amp;</code></li><li>…</li></ul><p>甚至你也可以通过设置里AutoStart选项卡进行添加。</p><blockquote><p>三种方法有不同的原理，但都可以做到开机自启，用什么就看情况了，个人推荐systemd的方法（便于管理）。</p></blockquote><h2 id="焕然一新">焕然一新</h2><p>重启，完事！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch折腾记 | 安装Windows/Arch双系统（一）</title>
      <link href="/2022/01/23/tutorial-archinstall-1/"/>
      <url>/2022/01/23/tutorial-archinstall-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想用Arch Linux做开发，但又不想干掉Windows？那装个双系统吧~</p></blockquote><blockquote><p>本篇内容主要基于<a href="https://wiki.archlinux.org/title/Installation_guide">Arch - Installation Guide</a>及<a href="https://www.viseator.com/2017/05/17/arch_install/">这篇很不错的博客</a>，写在前面表示感谢。</p></blockquote><p><strong>数据无价，请备份好重要数据再搞机。</strong></p><h2 id="预留新系统的空间">预留新系统的空间</h2><p>首先需要给你的Arch预留出空间，这个主要看你的使用情况，对我来说100G左右完全够了（不玩游戏，不跑机器学习，没有大型数据库）。</p><p>在Windows的“磁盘管理”中可以进行硬盘的压缩。预留出的空间应该是灰色的，表示没有被启用。</p><h2 id="制作启动盘">制作启动盘</h2><p>启动盘，一般推荐使用一个8G以上的U盘，因为除了镜像本体外，安装过程中的缓存文件也需要在启动盘的空间上保存，所以越大越好。</p><p>制作方式多种多样，我使用的工具是<a href="https://www.ventoy.net/cn/index.html">Ventoy</a>，非常傻瓜式：</p><ol><li>下载安装Ventoy；</li><li>下载所需系统的iso镜像；</li><li>插入U盘，打开Ventoy，用它来格式化U盘（原有数据会被清空）；</li><li>将iso复制进格式化后的U盘里，可以复制多个；</li><li>制作完成。</li></ol><p>没了。</p><h2 id="关闭安全启动（secure-boot）">关闭安全启动（secure boot）</h2><p>值得注意的是，无论是Arch Linux的安装，还是我用到Veotoy启动盘，都<strong>不支持</strong>安全启动（secure boot）。大部分主板默认是关闭了这个，但不妨进入BIOS看一眼，确认这玩意是关掉的。</p><p>具体请看<a href="https://wiki.archlinux.org/title/Installation_guide#Boot_the_live_environment">Arch不支持安全启动</a>和<a href="https://www.ventoy.net/cn/doc_secure.html">Ventoy不支持安全启动</a>。</p><h2 id="从U盘启动电脑">从U盘启动电脑</h2><p>下面开始安装新的系统，需要从我们的启动盘启动，所以先插上。</p><ul><li>对于Windows 10，“设置”里提供了“更新和安全 - 恢复 - 高级启动”的启动方式，点击里面的重启后，会进入蓝屏画面，选择从你的U盘启动；</li><li>通用办法则是开机进入BIOS（这个不同主板品牌，进入方式可能不一样），应该有个类似“启动顺序”的玩意，选择从U盘启动；</li></ul><p>对于Ventoy启动盘，它会进入到类似这样一个页面：</p><p><img src="/img/archinstall1.png" alt=""></p><p>选项里面是你放进去的iso系统镜像，按上下键选中想安装的系统，确认即可。<br>对于其他工具制作的启动盘，可能有不同的界面，但最终选好系统、开始安装后看到的就是一样的了。</p><h2 id="Arch安装方式一：Installation-Guide">Arch安装方式一：Installation Guide</h2><p>进去之后会有个大大的Arch Linux的logo，然后下面选择安装方式，总之选第一个就可以。</p><p>然后他会出一堆的DEBUG命令，反正左边现实绿色OK就不用管。最后进入了一个命令行界面，才是正式开始。<s>是的Arch的安装界面是命令行，很简陋吧哈哈哈</s></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # </span><br></pre></td></tr></table></figure><h3 id="确定键盘布局">确定键盘布局</h3><p>虽然一般不会用到，但假如你的键盘布局并不是US类型（指QWERTY那玩意，是默认的），需要在这里找到你要的布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # ls /usr/share/kbd/keymaps/**/*.map.gz</span><br></pre></td></tr></table></figure><p>布局名字就是最后一个<code>/</code>和<code>.map.gz</code>之间的字符串，比如默认的<code>us</code>，然后启用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # loadkeys us</span><br></pre></td></tr></table></figure><p>随便敲点什么，看有没有问题。</p><h3 id="检查引导方式">检查引导方式</h3><p>这个一般来说也不需要，毕竟在制作启动盘的时候已经选好了引导方式。假如还不太清楚的话，可以输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure><p>这是UEFI引导下才会存在的一个路径，因此，如果提示路径不存在那就是BIOS。<br>引导方式不同会影响到后面的部分安装步骤，但现在的电脑都是以UEFI居多，我也主要介绍这一边。</p><h3 id="连接网络">连接网络</h3><p>这是安装Arch我认为最重要的前提：<strong>把网络接好</strong>，因为Arch的整个安装流程基本都要基于网络。</p><p>先查看一下网络设备:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # ip link</span><br></pre></td></tr></table></figure><p>这会显示你的网卡、无线网卡设备（名称是比较容易辨认的，比如无线网卡就是<code>wlan</code>），然后根据你的网络：</p><ul><li><p>对于有线网络，可以使用<a href="https://wiki.archlinux.org/title/DHCP">DHCP</a>连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # dhcpcd</span><br></pre></td></tr></table></figure></li><li><p>对于无线网络，可以使用<a href="https://wiki.archlinux.org/title/Iwd#iwctl">iwctl</a>连接，这里需要记住上面<code>ip link</code>输出的那个无线网卡设备名（比如<code>wlan0</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # iwctl</span><br><span class="line">[iwd]# station wlan0 scan</span><br><span class="line">[iwd]# station wlan0 get-networks</span><br></pre></td></tr></table></figure><p>现在网卡<code>wlan0</code>扫描到了你的wifi，进行连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[iwd]# station wlan0 connect YOUR_WIFI</span><br></pre></td></tr></table></figure><p>输入密码完成连接，然后用<code>quit</code>或者<code>exit</code>退出即可。</p></li></ul><p>测试一下网络吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # ping www.bing.com</span><br></pre></td></tr></table></figure><p>没啥问题就棒(๑•̀ㅂ•́)و✧，进行下一步。</p><h3 id="设置时区">设置时区</h3><p>这个命令可以用来查看时区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # timedatectl list-timezones</span><br></pre></td></tr></table></figure><p>然后设置时区，并启动时间同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # timedatectl set-timezone Asia/Shanghai</span><br><span class="line">root@archiso ~ # timedatectl set-ntp true</span><br></pre></td></tr></table></figure><p>再通过这个命令检查一下时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # timedatectl status</span><br></pre></td></tr></table></figure><p>没问题就好。</p><h3 id="磁盘分区与格式化">磁盘分区与格式化</h3><p><strong>！！！这里特别注意不要手残干掉了原有数据（甚至系统文件），如果出现未知错误，请立刻谷歌！！！</strong></p><p>首先查看一下现有磁盘分区情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # fdisk -l</span><br></pre></td></tr></table></figure><p>最重要的是要看类似下面的段落：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: XXX GiB, XXX bytes, XXX sectors</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Device      Start   End     Sectors Size    Type</span><br><span class="line">/dev/sda1   XXX     XXX     XXX     XXX     XXX</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>/dev/sda</code>是指电脑里的一个叫<code>sda</code>的硬盘，以此类推；</li><li><code>/dev/sda1</code>是指<code>sda</code>硬盘里的<code>sda1</code>分区，以此类推；</li></ul><p>比如我给Arch预留的空间是在<code>/dev/sda</code>硬盘里面，则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # fdisk /dev/sda</span><br></pre></td></tr></table></figure><p>进入到fdisk的操作界面，输入<code>m</code>可以查看全部命令（并不多，都可能用到）。</p><p>磁盘分区方案可以看<a href="https://wiki.archlinux.org/title/Installation_guide#Example_layouts">官方的建议</a>，总之只需要注意：</p><ol><li>假如搞砸了，不要写入，直接输入<code>q</code>退出重来；</li><li>不同引导方式（UEFI or BIOS）有不同的分区要求；</li><li>注意分区类型（Partition type），一定要对的上；</li><li>注意分区地址，不要有重合，尽量不要有遗漏；</li><li>不要误修改了现有的分区；</li></ol><blockquote><p>建立新分区的时候，会让你输入&quot;分区编号&quot;和&quot;分区的起始地址&quot;：</p><ul><li>编号只要和现有的不同即可，没有要求；</li><li>地址区域不能重合，默认自动检测未使用的区域；</li></ul></blockquote><p>写入之前，再三检查一下分区，没问题就可以按<code>w</code>写入。</p><p>分区完成后，需要对磁盘空间进行格式化，以准备正式安装。</p><ul><li><p>这里我把主分区格式化为ext4的格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # mkfs.ext4 /dev/ROOT_PARTITION</span><br></pre></td></tr></table></figure></li><li><p>假如创建了SWAP分区，则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # mkswap /dev/SWAP_PARTITION</span><br></pre></td></tr></table></figure></li><li><p>假如创建了EFI分区，则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # mkfs.fat -F 32 /dev/EFI_PARTITION</span><br></pre></td></tr></table></figure></li></ul><h3 id="挂载与系统安装">挂载与系统安装</h3><p>写到这里，一切准备就绪，你可以开始把Arch装到硬盘上了。</p><p>首先挂载之前的分区：</p><ul><li>主分区：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # mount /dev/ROOT_PARTITION /mnt</span><br></pre></td></tr></table></figure></li><li>假如是UEFI引导，EFI分区：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # mkdir /mnt/boot</span><br><span class="line">root@archiso ~ # mount /dev/EFI_PARTITION /mnt/boot</span><br></pre></td></tr></table></figure></li><li>假如有SWAP分区：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # swapon /dev/SWAP_PARTITION</span><br></pre></td></tr></table></figure></li></ul><p><code>/mnt</code>这个目录就是Arch的目录结构雏形，现在需要把它的核心文件下载进去。</p><p>更换国内下载源（假如是国内网络原本的源会很慢），这里可以利用<a href="https://archlinux.org/mirrorlist/">官方的选源工具</a>。把生成出来的地址加进这里面去，顺序要排前面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>改好之后用这个命令开始下载安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # pacstrap /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure><p><s>好了，整了这么久，喝杯水，上个厕所去吧。</s></p><p>生成fstab自动挂载文件（以后开机挂载就不用手撸了）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h3 id="进入新系统">进入新系统</h3><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>神圣的一刻到来了！自此，你的命令行就变成了这玩意（<s>对还是命令行</s>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]#</span><br></pre></td></tr></table></figure><p>这是你硬盘上的Arch Linux，而不再是启动盘上那个了，妙啊妙啊（<s>不是</s>）。</p><p>现在又有些杂七杂八的东西需要设置：</p><ul><li><p>必备软件：（如文本编辑器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# pacman -S vim </span><br></pre></td></tr></table></figure></li><li><p>时区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">[root@archiso /]# hwclock --systohc</span><br></pre></td></tr></table></figure></li><li><p>语言：<br>在<code>/etc/locale.gen</code>里面取消注释所要用的语言，强烈建议要包括&quot;en_US.UTF-8 UTF-8&quot;（中文的话还需要&quot;zh_CN.UTF-8 UTF-8&quot;）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# vim /etc/locale.gen</span><br><span class="line">[root@archiso /]# locale-gen</span><br></pre></td></tr></table></figure><p>然后创建<code>/etc/locale.conf</code>并填入全局界面语言，推荐使用英文（不然在路径上可能有问题）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure></li><li><p>主机名（不是用户名）：</p><p>创建<code>/etc/hostname</code>并填入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YOUR_HOSTNAME</span><br></pre></td></tr></table></figure></li><li><p>网络：</p><p><a href="https://wiki.archlinux.org/title/Network_configuration/Wireless">无线连接</a>和<a href="https://wiki.archlinux.org/title/Network_configuration/Ethernet">有线连接</a>的驱动不妨都安装了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# pacman -S wpa_supplicant dhcpcd</span><br></pre></td></tr></table></figure></li><li><p>CPU补丁（Intel或Amd）：</p><p><a href="https://wiki.archlinux.org/title/Microcode">官方文档</a>说有用，反正装了吧（我的是Intel）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# pacman -S intel-ucode</span><br></pre></td></tr></table></figure></li><li><p>开机引导工具：</p><p>可以在<a href="https://wiki.archlinux.org/title/Arch_boot_process#Boot_loader">这里</a>随意选择，我用的是<a href="https://wiki.archlinux.org/title/GRUB">Grub</a>，根据引导方式不同要做的也会有差别，以UEFI为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# pacman -S grub efibootmgr os-prober</span><br><span class="line">[root@archiso /]# grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</span><br></pre></td></tr></table></figure><p>对于双系统（特别是非Linux），需要在<code>/etc/default/grub</code>大约最后的地方取消掉这个的注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DISABLE_OS_PROBER=false</span><br></pre></td></tr></table></figure><p>现在写入GRUB：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></li></ul><p>非必须的设置如下：</p><ul><li><p>管理员用户密码（不设的话管理员账户默认禁用，即只能用<code>sudo</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# passwd</span><br></pre></td></tr></table></figure></li><li><p>键盘布局（US布局可以不用）：</p><p>创建<code>/etc/vconsole.conf</code>并填入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYMAP=us</span><br></pre></td></tr></table></figure></li></ul><p>一切准备就绪，输入<code>exit</code>退出到启动盘的命令行，然后<code>reboot</code>重启试试。</p><p>现在你进入到了<s>tmd还是</s>命令行，由于还没加入用户，我们使用root管理员账号登录，再输入刚刚设置的密码，这就是Arch啦~！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch login: root</span><br><span class="line">Password: </span><br><span class="line"></span><br><span class="line">[root@YOUR_HOSTNAME ~]#</span><br></pre></td></tr></table></figure><h2 id="Arch安装方式二：Archinstall">Arch安装方式二：Archinstall</h2><p>如果想快速简单地安装Arch Linux，官方也提供了另一个途径：<a href="https://wiki.archlinux.org/title/Archinstall">Archinstall</a>一步到位。</p><p>同样是需要先<a href="#%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C">联网</a>，然后直接输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # archinstall</span><br></pre></td></tr></table></figure><p>他会自行走完所有必要的流程：</p><ol><li>设置时区；</li><li>设置软件镜像来源；</li><li>格式化分区、安装系统、挂载分区；</li><li>设置用户；</li><li>设置开机引导。</li></ol><p>这是个挺棒的玩意，但并不能帮助了解Linux的底层架构，因此有时间有想法的话，建议还是使用方式一。（<s>都用Arch了，加强下动手能力也好</s>）这里就不详细介绍了，应该是不难的。</p><h2 id="联网">联网</h2><p>从现在开始，启动盘可以拔了，我们开始在装好了的Arch里面搞东西。</p><p>显然，这需要再次联网。首先查看网络设备（设备名字可能和启动盘那会儿看到的不同了）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# ip link</span><br></pre></td></tr></table></figure><p>联网工具就是之前安装进来的那些，就我举的例子来说，是安装了<a href="https://wiki.archlinux.org/title/Dhcpcd">dhcpcd</a>和<a href="https://wiki.archlinux.org/title/Wpa_supplicant#Connecting_with_wpa_passphrase">wpa_supplicant</a>：</p><ul><li>有线：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# dhcpcd</span><br></pre></td></tr></table></figure></li><li>无线：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# wpa_passphrase &quot;WIFI_NAME&quot; &quot;WIFI_PASSWORD&quot; &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">[root@YOUR_HOSTNAME ~]# wpa_supplicant -B -i INTERFACE -c /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">[root@YOUR_HOSTNAME ~]# dhcpcd</span><br></pre></td></tr></table></figure></li></ul><p>若无意外的话，现在就已经有一个网络地址分配过来了，可以通过<code>ip addr</code>或者直接<code>ping</code>来检查网络。</p><h2 id="用户">用户</h2><p>到目前为止，我们还是用root管理员账号进行设置，但这是很不安全，最好能是一个“管理员权限随用随取的普通用户”。</p><p>在Arch里面，用户是<a href="https://wiki.archlinux.org/title/Users_and_groups#Group_list">分组管理</a>的，每个组别具有不同的身份和权限。根据我们的需求（root之下，普通之上），可以放到&quot;wheel&quot;用户组里面。</p><p>新建用户并记入wheel组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# useradd -m -G wheel USER_NAME </span><br></pre></td></tr></table></figure><p>为其设置密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# passwd USER_NAME</span><br></pre></td></tr></table></figure><p>安装<code>sudo</code>，这玩意就是用来让普通用户获取管理员权限的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# pacman -S sudo</span><br></pre></td></tr></table></figure><p>给wheel用户组赋予sudo权限，这里默认的文本编辑器是vi，但那玩意太丑了，因此我们把它软连接到vim上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@YOUR_HOSTNAME ~]# ln -s /bin/vim /bin/vi</span><br><span class="line">[root@YOUR_HOSTNAME ~]# visudo</span><br></pre></td></tr></table></figure><p>找到这么一行并取消前面的注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%wheel ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>用户创建完成，以后就可以用新的用户登陆了（而且命令行的提示符会从<code>#</code>变成<code>$</code>，表示非root用户）。</p><blockquote><p>p.s. 命令<code>su USER_NAME</code>可以用来切换不同的用户；命令<code>su</code>可以进入root用户；命令<code>sudo XXXX</code>表示用非root用户用root权限来运行命令；它们都可能需要输入用户密码哦。</p></blockquote><h2 id="开始使用">开始使用</h2><p>有了用户，有了联网，就能自行下载各种软件包并保存到本地使用。如果你的电脑用作服务器的话，实际上这已经足够了。<br>但要是日常用，这黑不溜秋的命令行界面确实不是一般人能接受的，下一篇我会讲点图形化的东西。<s>装了半天机。。累了。。休息去了。。</s></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows折腾记 | Microsoft Visual C++工具安装</title>
      <link href="/2022/01/21/tutorial-vcbuildtool/"/>
      <url>/2022/01/21/tutorial-vcbuildtool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写代码还是用Linux吧。。省心</p></blockquote><p>最近在给一台新电脑配置编译环境，因为测试要用，整的是windows系统，实在让人不省心。<br>废话不多说，总之本篇重点就是要整在编译Python包（底层涉及C++代码）时的这个错误：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: </span><br><span class="line">Microsoft Visual C++ <span class="number">14.0</span> or greater is required. </span><br><span class="line">Get it with <span class="string">&quot;Microsoft C++ Build Tools&quot;</span>: https://visualstudio.microsoft.com/visual<span class="literal">-cpp-build-tools</span>/</span><br></pre></td></tr></table></figure><p>这里“14.0”理论上也可能提示其他版本，总之没差，问题就在于少了个叫Microsoft Visual C++的编译工具。</p><h2 id="为什么要装这玩意">为什么要装这玩意</h2><p>不知道有没有人关注过为什么Windows下编译Python需要这玩意（<s>其实我也没关注</s>），但实际上在Python的官方Wiki上有<a href="https://wiki.python.org/moin/WindowsCompilers">这个说明</a>。总而言之就是在Windows下没有内置（完善的）C++编译器，所以需要自行安装：</p><table><thead><tr><th>Visual C++</th><th>CPython</th></tr></thead><tbody><tr><td>14.X</td><td>3.5, 3.6, 3.7, 3.8, 其实3.9也是</td></tr><tr><td>10.0</td><td>3.3, 3.4</td></tr><tr><td>9.0</td><td>2.6,2.7,3.0,3.1,3.2</td></tr></tbody></table><p>上面提示的VC++版本应该就是基于Python版本来的。</p><h2 id="怎么装">怎么装</h2><h3 id="通过官方提示">通过官方提示</h3><p>根据命令行提示的链接，打开<a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">https://visualstudio.microsoft.com/visual-cpp-build-tools/</a>，下载生成工具，启动！然后你就会发现，这是个什么玩意儿？？</p><p><img src="/img/vcbuildtool1.png" alt=""></p><p><s>巨硬兄，我只想装个编译工具，可不是想搞全家桶欸</s></p><p>此处省略掉各种搜索资料的过程，总之我发现只需要点选安装第一个“使用C++的桌面开发”即可，这玩意也得要几个G。</p><p>静候安装结束，在“已安装”里面就有了。（名字和我这不一样没关系）</p><p><img src="/img/vcbuildtool2.png" alt=""></p><ul><li>如果后续要添加更多功能的话可以，点“修改”；</li><li>如果安装报错了，点“更多-修复”，进行重装；</li><li>如果不想要了，点“更多-卸载”；</li></ul><h3 id="其他方式">其他方式</h3><p>值得一提的是，我在网上搜索的时候也发现有另一个安装程序：<a href="http://go.microsoft.com/fwlink/?LinkId=691126">http://go.microsoft.com/fwlink/?LinkId=691126</a>，这似乎是什么VC++ 2015的编译工具安装包，也是可信可用的。</p><p>但是这边我没找到什么官方文档，有可能被弃用了，所以并不作为第一选择。</p><blockquote><p>p.s. 根据亲身体验，这玩意经常下载失败：“安装包丢失或损坏”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch折腾记 | clash安装</title>
      <link href="/2022/01/03/tutorial-clash/"/>
      <url>/2022/01/03/tutorial-clash/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇不涉及机场/节点，也并不是科学上网教程。只是因为Arch官网上的clash教程实在太简洁，所以记录一下我捣鼓这玩意的过程。</p></blockquote><h2 id="Clash主程序安装">Clash主程序安装</h2><p>安装主程序非常简单，如<a href="https://wiki.archlinux.org/title/clash">官网</a>所说，我们只需要安装官方源里的包就好了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S clash</span><br></pre></td></tr></table></figure><p>然后<a href="https://github.com/alecthw/mmdb_china_ip_list/blob/master/README_en.md#fixed-download-connection">手动下载</a>一个叫<code>Country.mmdb</code>的玩意，咱也不用了解这是什么个原理，但如果想出去得用到这玩意就是了。下好之后放到<code>~/.config/clash</code>里（可能要新建文件夹）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p ~/.config/clash</span><br><span class="line">$ <span class="built_in">cd</span> ~/.config/clash</span><br><span class="line"><span class="comment"># 阿里源</span></span><br><span class="line">$ wget http://www.ideame.top/mmdb/Country.mmdb</span><br><span class="line"><span class="comment"># Github Release （国内网络可能不稳）</span></span><br><span class="line">$ wget https://raw.githubusercontent.com/alecthw/mmdb_china_ip_list/release/Country.mmdb</span><br></pre></td></tr></table></figure><p>然后可以把clash的配置文件<code>xxx.yaml</code>放到上面的文件夹里面，名字建议使用<code>config.yaml</code>，<s>毕竟这样就可以少写一个参数了</s>，启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数：-d，运行环境所在的文件夹，包括Country.mmdb、配置文件等</span></span><br><span class="line"><span class="comment"># 参数：-f，启用配置文件，默认是config.yaml</span></span><br><span class="line">$ clash -d ~/.config/clash -f config.yaml&amp;</span><br></pre></td></tr></table></figure><p>一切顺利的话可能会看到一些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO[0000] Start initial compatible provider XXXX</span><br></pre></td></tr></table></figure><p>它们是clash配置文件内的分组，没啥用，完事。</p><h2 id="开始使用-2">开始使用</h2><p>上面说到咱成功启动了clash，但要让各种流量自动从clash的端口进出，我们需要打开LAN许可并设置端口。</p><p>在配置文件<code>config.yaml</code>的开头（可能）有这些参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span>                  <span class="comment"># HTTP/HTTPS 端口</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span>             <span class="comment"># 允许局域网内连接</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">:9090</span>  <span class="comment"># 外置管理器端口，后面会用到</span></span><br><span class="line"><span class="attr">secret:</span>                     <span class="comment"># 外置管理器连接密钥</span></span><br></pre></td></tr></table></figure><p>如上，假如我们允许局域网连接，那么其他软件就可以设置proxy为<code>http://127.0.0.1:7890</code>，从而（其他协议如SOCK5同理，只需要写上对应参数就行）。</p><p>此外，我用了网页<a href="https://yacd.haishan.me/">YACD</a>可视化界面，登陆端口使用<code>127.0.0.1:9090</code>（就是上面提到的外置管理器端口）。它支持LAN端口更改、节点选择、流量记录等功能，这里不详细说了。</p><h2 id="自启动管理">自启动管理</h2><p>到目前为止，我们的clash还是需要手动启动，但如果有高强度冲浪选手需要开机自启动咋办呢。这里介绍基于<code>systemd</code>的自启动设置。</p><p>要使用<code>systemd</code>来控制软件服务，需要写一个<code>*.service</code>配置文件。正巧，如果是通过<code>pacman</code>来安装clash的话，他其实已经在<code>/usr/lib/systemd/user</code>写了一个简单的<code>clash.service</code>文件，可以在<a href="https://github.com/archlinux/svntogit-community/blob/packages/clash/trunk/PKGBUILD">PKGBUILD</a>里面看到。</p><blockquote><p>下面介绍的是基于当前用户的自启动，我把配置文件直接放在<code>~/.config/systemd/user</code>里面。但如果要控制其他用户，则应当放在<code>/usr/lib/systemd/user</code>或者<code>/usr/lib/systemd/system</code>内，步骤类似，这里不详细介绍。</p></blockquote><p>咱们把他复制过来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p ~/.config/systemd/user</span><br><span class="line">$ <span class="built_in">cd</span> ~/.config/systemd/user</span><br><span class="line">$ <span class="built_in">cp</span> /usr/lib/systemd/user/clash.service ./</span><br><span class="line">$ <span class="built_in">cat</span> clash.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=A rule based proxy in Go.</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=exec</span><br><span class="line">Restart=on-abort</span><br><span class="line">ExecStart=/usr/bin/clash</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><p>这里我们只需要关注<code>ExecStart</code>参数，他相当于是<code>systemd</code>启动clash的命令。对比上面我们自己写的命令后发现，他少了点东西：</p><ul><li><code>-d</code>，运行环境所在的文件夹</li><li><code>-f</code>，启动配置文件（<s>但我用的是默认名所以可以不写这个</s>）</li></ul><p>据此，修改上述参数为：<strong>（注意这里不能用“~”代指用户目录，要写全路径）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/clash -d /home/&#123;username&#125;/.config/clash</span><br></pre></td></tr></table></figure><p>把<code>systemd</code>给重载一下，并尝试启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload --user</span><br><span class="line">$ systemctl start clash --user</span><br></pre></td></tr></table></figure><p>使用<code>systemctl status clash --user</code>查看一下服务启动情况，如果输出无异常那就成了。</p><p>现在可以打开自启服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> clash --user</span><br></pre></td></tr></table></figure><p>然后在当前用户目录<code>~/.config/systemd/</code>内就会生成一个指向<code>clash.service</code>的链接，从而为这个用户创建了自启动。（如果是系统层面的自启动，会创建在<code>/etc/systemd/system</code>内）</p><p>完事。</p><h2 id="订阅设置">订阅设置</h2><p>此外，像我这种懒人，是通过机场订阅节点的，所以也需要一个工具来更新订阅（不然每次都得手动下载配置文件也挺麻烦的）。这里用了官网推荐的<a href="https://aur.archlinux.org/packages/clashup/">clashup</a>，一个AUR包。</p><p>根据作者提供的<a href="https://github.com/felinae98/clashup#config">Github介绍</a>，我们需要创建<code>~/.config/clash/clashup.json</code>并写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 端口设置，会覆盖下载后的配置</span></span><br><span class="line">    <span class="attr">&quot;http_port&quot;</span><span class="punctuation">:</span> <span class="number">7890</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;socks5_port&quot;</span><span class="punctuation">:</span> <span class="number">7891</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;redir_port&quot;</span><span class="punctuation">:</span> <span class="number">7892</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;allow_lan&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;external_controller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:9090&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 订阅链接，以及它是否被墙</span></span><br><span class="line">    <span class="attr">&quot;subscribe_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;is_subscribe_banned&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;custom_rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 如果下面这俩都写了，则clashup也会顺带更新Country.mmdb</span></span><br><span class="line">    <span class="attr">&quot;mmdb_file_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://www.ideame.top/mmdb/Country.mmdb&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;mmdb_version_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://www.ideame.top/mmdb/version&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>实际上很多参数和clash的配置文件<code>config.yaml</code>是一样的，他的目的是覆盖下载后的文件内的对应配置，所以也算是一个端口管理工具。</p><p>现在利用<code>clashup --update</code>命令即可更新配置文件，别忘了还要restart一下clash服务。</p><blockquote><p>需要注意的是，clashup更新的文件只能是<code>config.yaml</code>（如果没有则会创建）。所以使用这玩意的时候，clash配置文件名并不能随便取。<s>当然，更新后把文件重命名也不是不行。</s></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch折腾记 | PKGBUILD怎么写</title>
      <link href="/2021/12/08/tutorial-pkgbuild-1/"/>
      <url>/2021/12/08/tutorial-pkgbuild-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>自安装了ArchLinux以来，准确的来说是从AUR安装东西以来，就一直想学PKGBUILD的写法。但是因为太懒没有动力，就一直拖着。直到最近想装个东西，但它没提供Arch包，这才整了整活。</p></blockquote><blockquote><p>跟着其他教程弄了半天，总算装上能用了，但写得肯定不够规范，以后有空了再更新吧~</p></blockquote><h2 id="PKGBUILD和AUR">PKGBUILD和AUR</h2><p>使用ArchLinux的朋友可能不陌生，AUR（Arch User Repository）是一个用户自行打包、分享软件的平台，其安全性和稳定性虽然没法保证。但一般来说，只要安装有人气的包就没大问题。对于官方来说，也会将符合一些<a href="https://wiki.archlinux.org/title/Arch_User_Repository_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#PKGBUILD%EF%BC%88AUR_%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%89%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A2%AB%E6%94%B6%E5%BD%95%E5%88%B0_community_%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93%EF%BC%9F">条件</a>的包收录到官方库里面去。是ArchLinux社区的重要组成部分（这说法好官方哈哈哈哈哈）。</p><p>这无穷无尽的软件想要都塞给官方来保存，人又不是网盘，顶不住这么折腾，于是PKGBUILD就是一个很好的解决方式。</p><p>简单来说，PKGBUILD这个文件（对，它只是一个文本文件罢了）负责记录：</p><ul><li>从哪来：软件数据从哪里下载</li><li>到哪去：怎么安装，安装到哪</li></ul><blockquote><p>大陆网络有时会发现无法下载AUR的包，如果不是PKGBUILD写错了，那么很大概率是连不上作者指定的下载源（你懂的）</p></blockquote><p>这么一来，只要写好一份PKGBUILD，并在下载源（比如本地，或者Github之类的）放好软件数据，就可以交给<code>makepkg</code>命令来安装了，nice！</p><p>而如果要提交上AUR给大伙瞧瞧，还得在里面写好软件版本、作者信息、许可证、完整性检验等等更规范的玩意，当然也得负责后续更新以及bug的处理。当然，本篇并不关注这些，咱只想装个AUR里面没有的包罢了。</p><h2 id="PKGBUILD结构">PKGBUILD结构</h2><p>前面说到，PKGBUILD实际上就是一个文本文档，它的结构在<a href="https://wiki.archlinux.org/title/Creating_packages_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Wiki</a>里已经有比较好的说明了。</p><p>不妨先把<code>/usr/share/pacman/PKGBUILD.proto</code>这个模板复制一份到某个空文件夹里面（这个文件夹就是后续的操作目录），去掉后缀。<br>当然，在我的简单需求下，并不是所有的参数都需要用到，只需要关注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pkgname=XXX         # 包名</span><br><span class="line">pkgver=0.0.1        # 版本</span><br><span class="line">pkgrel=1            # 版本发布号（每个版本从1开始，相当于小版本）</span><br><span class="line">arch=(&#x27;x86_64&#x27;)     # 支持的CPU架构</span><br><span class="line">license=(&#x27;unknown&#x27;) # 许可证（我只是自用，所以unknown就好）</span><br><span class="line">depends=()          # 依赖的其他包</span><br><span class="line"></span><br><span class="line">prepare() &#123;</span><br><span class="line">    # 【准备阶段】</span><br><span class="line">    # 写下载软件源文件的东西</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">    # 【编译阶段】</span><br><span class="line">    # 从下载好的玩意里编译出可安装的文件，一般以make结尾</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package() &#123;</span><br><span class="line">    # 【安装阶段】</span><br><span class="line">    # 安装到指定目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模板里其他部分并不是不重要，如果需要提交AUR的话还是必须了解所有功能的，但对于我来说已经够用了</p></blockquote><p>注意到这整个安装过程分了好几个阶段，它们实际上是会按顺序来的。换句话说，如果你喜欢，也可以把所有步骤全扔到比如<code>package()</code>里面，也同样能跑。<br>但之所以这么分，是因为我们的安装不一定会走完全流程，比如：</p><ul><li>已经下载好了源文件，直接本地编译就行，那就不用跑<code>prepare()</code></li><li>已经编译好了，只想重装一下，那就不用跑<code>prepare()</code>和<code>build()</code></li></ul><p>正因为有这些更灵活的需求，我还是建议尽量分开各个步骤。</p><h2 id="安装，更新与卸载">安装，更新与卸载</h2><h3 id="安装">安装</h3><p>写好了PKGBUILD之后，在PKGBUILD所在的文件夹里面，可以使用<code>makepkg</code>命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ makepkg -si    <span class="comment"># 加-s自动安装依赖包， -i编译后安装</span></span><br></pre></td></tr></table></figure><p>而且你还会发现搞定后多出了一个<code>src</code>文件夹，一个<code>pkg</code>文件夹，和一个<code>*.pkg.tar.zst</code>文件：</p><ul><li><code>src</code>：下载及预处理后的软件源文件；</li><li><code>pkg</code>：一个软件安装虚拟环境（沙箱？），如果安装成功，会被复制到根目录去；</li><li><code>*.pkg.tar.zst</code>：打包好的二进制文件，以后可以使用<code>pacman -U</code>直接安装。</li></ul><p>所以简单来说，除了最后一个可以保存以便重新安装，其他都没啥用。</p><h3 id="更新">更新</h3><p>更新十分简单，只需要修改PKGBUILD的<a href="https://wiki.archlinux.org/title/PKGBUILD_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E7%89%88%E6%9C%AC">版本相关参数</a>（包括pkgver，pkgrel等），重新运行<code>makepkg</code>即可。</p><h3 id="卸载">卸载</h3><p>对于安装到正确位置的软件包，都能被Pacman正确识别到信息，然后和别的软件包一样使用<code>sudo pacman -R</code>就好啦~</p><h2 id="举个栗子：Terminus-Player">举个栗子：Terminus Player</h2><blockquote><p>吐槽：网上搜的大多数教程具体的例子都不给，感觉看着太难受。。</p></blockquote><p>这里简单举个例子，以我想要安装的<a href="https://github.com/Terminus-Media/jellyfin-media-player">Terminus Player</a>为例。</p><h3 id="命令行安装">命令行安装</h3><p>在正式编写PKGBUILD之前，我推荐要先在命令行走一遍安装流程。<br>在<a href="https://github.com/Terminus-Media/jellyfin-media-player#building-at-a-glance-linux">Github简介</a>内，作者给出了命令行的安装方式，虽然是Ubuntu的，但我们完全可以借鉴这个步骤。</p><p>首先我习惯新开一个文件夹在里面操作，不妨就叫<code>terminus</code>好了。由于系统不同，我们直接跳过所有依赖包，开始它的安装步骤，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: terminus</span></span><br><span class="line">$ git <span class="built_in">clone</span> git://github.com/iwalton3/jellyfin-media-player</span><br><span class="line">$ <span class="built_in">cd</span> jellyfin-media-player</span><br><span class="line">$ ./download_webclient.sh</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ make </span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>在我的电脑上，进行第三行命令运行<code>./download_webclient.sh</code>时报了错误，少了个包：<a href="https://wiki.archlinux.org/title/Mpv_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">mpv</a>，这简单，用Pacman给它装上，再跑一遍。</p><blockquote><p>细心的话可以发现，其实Github作者给的安装步骤里是有类似mpv的东西。但对于像我一样使用另一个系统的朋友，还是建议先直接安装，有提示缺漏再补。（以避免安装错误或者不必要的安装。）</p></blockquote><p>安装顺利完成，留意一下安装路径（因为不一定符合要求）是在<code>/usr/local</code>里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...（前略）</span></span><br><span class="line">-- Installing: /usr/local/share/jellyfinmediaplayer/web-client/extension/jmpUpdatePlugin.js</span><br><span class="line">-- Installing: /usr/local/bin/jellyfinmediaplayer</span><br><span class="line">-- Set runtime path of <span class="string">&quot;/usr/local/bin/jellyfinmediaplayer&quot;</span> to <span class="string">&quot;/lib&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于我更希望和其他软件一起存在<code>/usr</code>里面，这样可以方便管理，因此可以给<code>make install</code>增加参数<code>make DESTDIR=&quot;/&quot; install</code>（但在PKGBUILD里面需要写成<code>$&#123;pkgdir&#125;</code>来代表根目录，而不是<code>/</code>，后面会提到）</p></blockquote><p>尝试打开，又发现了错误（雾）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">libpng warning: iCCP: known incorrect sRGB profile</span><br><span class="line">Logging to /home/hjh/.local/share/jellyfinmediaplayer/logs/jellyfinmediaplayer.log</span><br><span class="line">[1209/180802.041012:ERROR:resource_bundle.cc(947)] Failed to load /home/hjh/.Jellyfin Media Player/qtwebengine_resources_100p.pak</span><br><span class="line">Some features may not be available.</span><br><span class="line">[1209/180802.041050:ERROR:resource_bundle.cc(947)] Failed to load /home/hjh/.Jellyfin Media Player/qtwebengine_resources_200p.pak</span><br><span class="line">Some features may not be available.</span><br><span class="line">[1209/180802.041056:ERROR:resource_bundle.cc(947)] Failed to load /home/hjh/.Jellyfin Media Player/qtwebengine_resources.pak</span><br><span class="line">Some features may not be available.</span><br><span class="line">[1209/180802.041082:WARNING:resource_bundle_qt.cpp(119)] locale_file_path.empty() <span class="keyword">for</span> locale </span><br><span class="line">[18005:18005:1209/180802.124821:ERROR:extension_system_qt.cpp(121)] Failed to parse extension manifest.</span><br><span class="line">[1]    18005 segmentation fault (core dumped)  jellyfinmediaplayer</span><br></pre></td></tr></table></figure><p>好家伙，这我就只能交给谷歌了（此处花了几乎一个小时），终于在<a href="https://gitmemory.cn/repo/jellyfin/jellyfin-media-player/issues/152">这里</a>找到了方法，需要把<code>cmake</code>那一行命令加多一个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -DQTROOT=<span class="string">&quot;&#123;qt所在的文件夹&#125;&quot;</span> ..</span><br></pre></td></tr></table></figure><p>卸载（手动删除）掉之前装上的东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /usr/local/bin/jellyfinmediaplayer </span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /usr/local/share/jellyfinmediaplayer</span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /usr/local/resources/qtwebengine_devtools_resources.pak</span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /usr/local/share/applications/com.github.iwalton3.jellyfin-media-player.desktop</span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /usr/local/share/metainfo/com.github.iwalton3.jellyfin-media-player.appdata.xml</span><br></pre></td></tr></table></figure><p>重新安装成功，可以使用，nice！</p><blockquote><p>实际上到这里也可以直接使用了，但如果要管理软件会比较麻烦（比如卸载的话，要手动去删除软件）…</p></blockquote><h3 id="编写PKGBUILD">编写PKGBUILD</h3><p>有了成功的经验，我们便可以开始编写PKGBUILD了，新建一个文件<code>terminus/PKGBUILD</code>。<br>我直接把写好的放出来，大家对照着看解释即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pkgname=&quot;terminus&quot;</span><br><span class="line">pkgver=0.0.1</span><br><span class="line">pkgrel=1</span><br><span class="line">arch=(&quot;x86_64&quot;)</span><br><span class="line">depends=(&quot;mpv&quot; &quot;qt6-base&quot; &quot;cmake&quot;)  # 填上之前缺少的包</span><br><span class="line">license=(&quot;unknown&quot;)</span><br><span class="line"></span><br><span class="line">prepare() &#123; # 从Github下载软件源文件</span><br><span class="line">    mkdir &quot;$&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;&quot;</span><br><span class="line">    cd &quot;$&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;&quot;</span><br><span class="line">    git clone https://github.com/Terminus-Media/jellyfin-media-player.git</span><br><span class="line">    cd jellyfin-media-player</span><br><span class="line">    ./download_webclient.sh</span><br><span class="line">    rm -rf .github  # 干掉git clone下来的.github，非必要</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build() &#123;   # 编译并构建可安装文件</span><br><span class="line">    cd &quot;$&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;/jellyfin-media-player/build&quot;</span><br><span class="line">    cmake -DQTROOT=&quot;$&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;/jellyfin-media-player/qt&quot; ..</span><br><span class="line">    make</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package() &#123; # 安装</span><br><span class="line">    cd &quot;$&#123;srcdir&#125;/$&#123;pkgname&#125;-$&#123;pkgver&#125;/jellyfin-media-player/build&quot;</span><br><span class="line">    make DESTDIR=&quot;$&#123;pkgdir&#125;&quot; install</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我在这里用到了很多诸如<code>$&#123;srcdir&#125;</code>的玩意，这些是PKGBUILD的<a href="https://archlinux.org/pacman/PKGBUILD.5.html#:~:text=All%20of%20the%20above%20variables%20such%20as%20%24pkgname%20and%20%24pkgver%20are%20available%20for%20use%20in%20the%20packaging%20functions.%20In%20addition%2C%20makepkg%20defines%20the%20following%20variables%3A">“暗号”</a>，具体来说：</p><ul><li><code>$&#123;srcdir&#125;</code>：安装文件夹，实际上是与PKGBUILD同级的<code>terminus/src</code>文件夹（开始安装后会出现），可看作是安装过程中的根目录；</li><li><code>$&#123;pkgdir&#125;</code>：只应在<code>package()</code>里使用，对应着外部的根目录；</li><li><code>$&#123;pkgname&#125;</code>：前面定义的包名</li><li><code>$&#123;pkgver&#125;</code>：前面定义的版本</li></ul><p>现在用<code>makepkg</code>来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: terminus</span></span><br><span class="line">$ makepkg -si</span><br></pre></td></tr></table></figure><blockquote><p>注意：安装过程中有可能出现这个INSTALL路径错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at src/cmake_install.cmake:50 (file):</span><br><span class="line">    file INSTALL cannot find</span><br><span class="line">    <span class="string">&quot;terminus/src/terminus-0.0.1/jellyfin-media-player/build/src/../dist&quot;</span>:</span><br><span class="line">    No such file or directory.</span><br></pre></td></tr></table></figure><p>具体原因我还没搞清楚，但可以通过<code>rm -rf src pkg</code>删掉已有文件后重新来一遍解决。</p></blockquote><p>完事！</p><h2 id="修复PGP-marginal-trust-invalid问题">修复PGP: marginal trust / invalid问题</h2><p>我在某一次安装的时候遇到了类似这样的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: XXXXXX: signature from <span class="string">&quot;XXXXX&quot;</span> is marginal trust</span><br><span class="line">:: File /var/cache/pacman/pkg/XXXXXXXXXXX.pkg.tar.zst is corrupted (invalid or corrupted package (PGP signature)).</span><br><span class="line">Do you want to delete it? [Y/n]</span><br></pre></td></tr></table></figure><p>根据他的提示删除PGP签名又提示失败：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to commit transaction (invalid or corrupted package)</span><br></pre></td></tr></table></figure><p>其原理还没怎么搞懂，但至少是PGP签名出了问题。<br><a href="https://forums.scotsnewsletter.com/index.php?/topic/97267-arch-update-perculiarity-mujs-signature-from-daniel-bermond-is-marginal-trust/">这里</a>提到一种解决办法是检测并刷新所有签名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman-key --refresh-keys</span><br></pre></td></tr></table></figure><blockquote><p>注意：这行命令会运行很久很久，甚至超过半小时。但对系统负载不高，可以干别的。</p></blockquote><p>等待PGP刷新结束即可重新<code>makepkg -si</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建个站玩儿 | 第二期 - 弄好看点</title>
      <link href="/2021/12/03/tutorial-hexo-2/"/>
      <url>/2021/12/03/tutorial-hexo-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本来以为第一期就能讲到这…看来还是我太罗嗦了？</p></blockquote><h2 id="本地文件结构">本地文件结构</h2><p>想了想，感觉还是应该先介绍一下Hexo的文件夹结构，不然改个配置都不知道去哪改…</p><ul><li><p>配置：<code>_config.yml</code>和<code>_config.&#123;yourtheme&#125;.yml</code></p><p>Hexo进行生成的时候两个配置文件都会看，但如果有冲突项，后者（有主题名的那个）优先级更高。<br>其中<code>&#123;yourtheme&#125;</code>是你所使用的主题样式，默认是<code>landscape</code>。</p><blockquote><p>这是本篇最需要关注的文件，避免混淆，我后续把它们分别称为“Hexo配置文件”和”主题配置文件“。</p></blockquote></li><li><p>主题：<code>themes</code></p><p>用来放置各种主题，但有时候主题会被打包作为插件，那就会装在<code>node_modules/*</code>里面去。</p></li><li><p>插件：<code>node_modules</code>和<code>package.json</code></p><p>前者存放由<code>npm</code>安装的各种插件，比如搜索引擎、渲染器、主题。<br>如果要启用某个插件，需要写在<code>package.json</code>里面。</p></li><li><p>文章：<code>source</code></p><p>顾名思义，存放你写的文章内用到的各种源文件，比如图片、markdown代码。</p></li><li><p>网页：<code>public</code></p><p>Hexo生成完毕后出现，用于存放转换后的网页文件，也仅有这里面的东西会被推上网页那边。</p></li></ul><p>这就是比较重要的几个玩意了，其他的可以暂时不管。</p><h2 id="网页基本信息">网页基本信息</h2><p>基本信息，比如网站名、作者信息啥的，我们需要在<code>_config.yml</code>内改动。<br>下面我节选了一些比较重要的，其他可以到<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo官方文档</a>查看</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">空空</span> <span class="string">如也</span> <span class="string">(´･ω･`)?</span>           <span class="comment"># 网站名称</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">oooo26</span>                    <span class="comment"># 作者名称</span></span><br><span class="line"><span class="attr">language:</span>                         <span class="comment"># 语言（可以选择多个）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zh-tw</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">en</span>                   </span><br><span class="line"><span class="attr">url:</span> <span class="string">https://oooo26.github.io/</span>    <span class="comment"># 网站域名（前一篇设置过了）</span></span><br><span class="line"><span class="attr">deploy:</span>                           <span class="comment"># 部署对象（前一篇设置过了）</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/oooo26/oooo26.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>其他就自行了解吧，我们继续。</p><h2 id="主题">主题</h2><h3 id="更换主题">更换主题</h3><p><s>landscape虽然不难看，但强迫症就是想换掉默认的</s></p><p>Hexo支持一大堆主题，在<a href="https://hexo.io/themes/">这里</a>随便选随便挑~</p><blockquote><p>顺便记录一下我感觉还不错的：Butterfly, NexT, stun, Keep, LiveMyLife, Anatolo, Claudia, Diaspora, Volantis, yun, Arknights, Ayer, Autumn，向各位作者大佬致敬，我就点个star白嫖了哈哈哈</p></blockquote><p><strong>强烈建议仔细考虑主题</strong>，后续尽量不要改动，因为大部分配置都基于主题的配置文件，并且一些组件的位置也会影响我们的设置方案。</p><p>考虑完毕后，点击对应主题的名字，看看他们各自的安装教程（这就没法写统一的教程了）。<br>装好之后，主题会被存放在<code>themes</code>或是<code>node_modules</code>文件夹里面。一般来说它里面还会包含一个<code>_config.yml</code>，建议复制出来和外层<code>_config.yml</code>放在同一级，并改名为<code>_config.&#123;yourtheme&#125;.yml</code>，以后只需要更改外面这俩即可。</p><p>最后打开<code>_config.yml</code>并更改主题：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span>        <span class="comment"># 改成你想要的主题</span></span><br></pre></td></tr></table></figure><p>完事</p><h3 id="Butterfly主题">Butterfly主题</h3><p>我所选用的是Butterfly主题，如果你不是用的这个，那很抱歉不需要往下看了。<br><s>但我反正只是写给自己看，所以我自个继续哈哈哈</s></p><p>Butterfly有非常友善的<a href="https://butterfly.js.org/posts/21cfbf15/">文档</a>，而且作者也讲中文，有不会的东西可以直接提issue交流（不是说可以随便去麻烦的意思）。</p><h4 id="下载主题">下载主题</h4><p>官方提供了两种安装方法：</p><ul><li>从Github/Gitee下载主题文件，放到<code>themes</code>里面（后续利用<code>git</code>进行更新）</li><li>利用<code>npm</code>安装主题插件到<code>node_modules</code>里面（后续利用<code>npm</code>进行更新）</li></ul><blockquote><p>它俩基本没区别，但后者只提供稳定版本（反正一般也只装稳定）。</p></blockquote><p>假如使用Github备份源代码，建议使用第二种：因为第一种方法如果保留了主题文件夹内的<code>.git</code>，会导致<code>git push</code>的时候有点小问题（文件夹里包含两个上游仓库信息），但是不保留的话又没法快速更新。</p><p>总之装好之后，把<code>themes/hexo-theme-butterfly/_config.yml</code>或者<code>node_modules/hexo-theme-butterfly/_config.yml</code><br>复制到外层和<code>_config.yml</code>同级，并改名为<code>_config.butterfly.yml</code>。</p><h4 id="安装渲染器">安装渲染器</h4><p>Butterfly的页面需要两个渲染器才能使用，我们在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: my_hexo_fold</span></span><br><span class="line">$ npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>这样一来<code>hexo-renderer-pug</code>和<code>hexo-renderer-stylus</code>就被安装到了插件文件夹里面，并且由于<code>--save</code>命令，插件也被写进了<code>packages.json</code>开始启用。</p><h4 id="应用主题">应用主题</h4><p>更改<code>_config.yml</code>里面的子段<code>theme: butterfly</code>，然后重新进行Hexo生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: my_hexo_folder</span></span><br><span class="line">$ hexo cl &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><p>完事，好看多了不是吗</p><h2 id="页面配置（使用Butterfly）">页面配置（使用Butterfly）</h2><p>这一部分我想来想去，怎么写也肯定没有官方的文档详细好用…罢了，放个链接在这吧：<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly主题配置</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装汇总 | Linux/WSL</title>
      <link href="/2021/12/03/tutorial-linux-software/"/>
      <url>/2021/12/03/tutorial-linux-software/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇汇总了站内用到的各种Linux下软件的安装，主要是利用命令行，因此一些基本的命令行语法不会做过多解释。一般来说，我会以我自己的系统（Ubuntu 20.04）为例给出详细步骤，对于其他平台请参考我给出的其他教程链接（<s>尽量都会附上的，没有的话就算了</s>）。</p></blockquote><blockquote><p>部分教程需要科学上网工具，请尽量自备</p></blockquote><h2 id="Git">Git</h2><p>这个看<a href="https://git-scm.com/downloads">官方教程</a>就好，实际上就是从Linux官方源里下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git</span><br></pre></td></tr></table></figure><p>利用<code>git --version</code>查看版本，以确认安装成功。</p><h2 id="Node-js">Node.js</h2><h3 id="方案一：通过nvm安装">方案一：通过nvm安装</h3><p>Node Version Manager（简称nvm）是一个十分方便的Node.js管理器，可以很方便地进行安装、卸载、版本切换等，其<a href="https://github.com/nvm-sh/nvm">官方地址在此</a>。</p><p>首先需要安装nvm，这里只放命令行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;v0.39.0&quot; is the latest now</span></span><br><span class="line">$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>重启命令行，然后可以通过<code>nvm -v</code>查看安装版本，或者<code>nvm list</code>查看已有的Node.js版本，以检测是否安装成功。</p><p>下一步是安装Node.js，这里推荐安装稳定（stable）版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install stable version (recommend) </span></span><br><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>利用<code>nvm list</code>或者<code>node -v</code>可以查看所安装的版本，如果没有问题就搞定了。</p><h3 id="方案二：官网下载离线安装包">方案二：官网下载离线安装包</h3><p>如果不想装第三方软件，也可以直接从<a href="https://nodejs.org/zh-cn/download/">官网下载</a>离线安装包，这个就不赘述了，看准自己的平台即可。<br>最后也要记得利用<code>node -v</code>检测一下是否安装成功。</p><h3 id="方案三：从Linux官方源安装（不推荐）">方案三：从Linux官方源安装（不推荐）</h3><p>这个方案的确是最最简单的，但因为版本可能太旧（<s>我在安装的时候官方都出到16.x.x，Ubuntu官方源里居然还是10.x.x</s>），但也放出教程好了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install nodejs</span><br></pre></td></tr></table></figure><p>完事。<br>最后也要记得利用<code>node -v</code>检测一下是否安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo建个站玩儿 | 第一期 - 弄出个网站来</title>
      <link href="/2021/12/01/tutorial-hexo-1/"/>
      <url>/2021/12/01/tutorial-hexo-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>想了很久（大概半小时）到底要以什么文章来作为开站系列，最终还是打算把我这几天建站的流程给记录下来。一来可以当成笔记翻翻，二来也可以是本站发展史了。这个系列估计能贯穿小站的整个生命周期，但更新不会太频繁，实在是十分适合懒人开坑了。</p></blockquote><blockquote><p>注：本期未涉及Hexo的配置，仅为初始网站样式，配置的话请看第二期~</p></blockquote><h2 id="建站成本">建站成本</h2><p>在本地建站的话是不需要成本的，但一般我们需要部署到线上，而线上需要考虑两个点：</p><ul><li>有个域名（购买，或者白嫖Github Pages）</li><li>有个时刻在线的服务器/主机（购买，或者白嫖Github Pages）</li></ul><p><s>所以为什么不白嫖呢</s><br>如果你能达到要求的话，恭喜，其他就没有必须要花钱的地方了。</p><p>此外，为了有良好的体验，我也比较推荐掌握以下技术：</p><ul><li>markdown语法（发文章会用到，尽量掌握）</li><li>yml、json代码（不用会写，但最好能看懂结构，知道怎么改）</li><li>html、css代码（真正自定义网站的时候要用，大佬必备，我反正不会）</li></ul><p>总而言之，我们可以继续往下了。</p><h2 id="本地部署">本地部署</h2><p>首先把上面的所有东西都放一边，我们先利用Hexo建立一个初步的本地网站。<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>已经写的比较清楚了，我随便写点凑凑字数哈。</p><blockquote><p>如果使用自购服务器和域名，请直接在服务器上进行这部分操作。（除非你想在自己的电脑上试试水）</p></blockquote><p>安装基本的两个东西（命令行）：</p><ul><li>Node.js: <a href="https://nodejs.org/zh-cn/download/">官网下载</a>，或者通过<a href="/2021/12/03/tutorial-linux-software/" title="命令行下载">命令行下载</a>;</li><li>Git: <a href="https://git-scm.com/downloads">官网下载</a>，或者通过<a href="/2021/12/03/tutorial-linux-software/" title="命令行下载">命令行下载</a>;</li></ul><p>接下来进行Hexo的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm是Node.js带的包管理器</span></span><br><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>完事！</p><p>最后就是在本地开个新文件夹给他（存储网站源文件），一定记得要<code>cd</code> 进去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并进入文件夹</span></span><br><span class="line">$ <span class="built_in">mkdir</span> my_hexo_folder</span><br><span class="line">$ <span class="built_in">cd</span> my_hexo_folder</span><br><span class="line"><span class="comment"># 初始化（它会下载一堆配置文件进来）</span></span><br><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>文件夹里面大概长这样，各种文件我们晚点再说~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_hexo_folder</span><br><span class="line">    ├── _config.yml</span><br><span class="line">    ├── package.json</span><br><span class="line">    ├── scaffolds</span><br><span class="line">    ├── source</span><br><span class="line">    |   ├── _drafts</span><br><span class="line">    |   └── _posts</span><br><span class="line">    └── themes</span><br></pre></td></tr></table></figure><p>然后来看看一个初始的站点长什么样吧（激动.jpg），记住下面这套组合拳，我们以后每次更新文章都得用到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: my_hexo_folder</span></span><br><span class="line">$ hexo cl   <span class="comment"># clean     清空现有网站文件</span></span><br><span class="line">$ hexo g    <span class="comment"># generate  生成新网站文件</span></span><br><span class="line">$ hexo s    <span class="comment"># setup     本地部署到127.0.0.1:4000</span></span><br></pre></td></tr></table></figure><p>浏览器打开<a href="http://127.0.0.1:4000">http://127.0.0.1:4000</a>，大功告成~</p><h2 id="线上部署">线上部署</h2><p>下一步将阵地从本地转移到线上（<s>不然还怎么叫网站呢</s>）</p><h3 id="方案一：Github-Pages">方案一：Github Pages</h3><ol><li>注册一个Github账号（<s>废话</s>）；</li><li>新建一个仓库（想白嫖的话就用public的，氪金随意），取名为<code>&#123;yourname&#125;.github.io</code>（这里的<code>&#123;yourname&#125;</code><strong>必须</strong>是你的Github账号名）：</li><li>回到本地，打开<code>my_hexo_folder/_config.yml</code>找到下面两段配置，补上： <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set website url</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://&#123;yourname&#125;.github.io</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># set Github url</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li><li>运行Hexo生成并部署，现在能自动推上Github了（可能需要输入账号密码，这个与Git的配置有关，可以设置为记住，那就不用每次都输入了）； <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: my_hexo_folder</span></span><br><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li><li>坐下来，喝口水，然后打开<a href="">https://{yourname}.github.io</a>，搞定~</li></ol><blockquote><p>注：如果使用Private仓库，则需要充值成为Github会员才能仓库文件推到域名上，否则打开一直是404；<s>不开源不准白嫖？</s></p></blockquote><h3 id="方案二：自购服务器和域名">方案二：自购服务器和域名</h3><p>如果是自购服务器和域名的话，则需要找对应平台的教程，大致分为如下几个步骤：</p><ol><li>在服务器内建立本地站点（见上一部分），并启动本地部署；</li><li>将网站对应的端口开放到公网（或者映射啥的，只要能从外面连进来就行）；</li><li>将域名连接到你的服务器及端口上（这个域名提供商会有教程的）。</li></ol><p>不过我没弄这玩意，就不详细讲了。</p><h2 id="备份源码">备份源码</h2><p>需要注意的是，被推上Github和网站的文件仅有本地<code>my_hexo_folder/public</code>里面的内容。换句话说，你不能将Github上那些玩意扒下来再重复做一次Hexo生成。<s>已经六亲不认了</s></p><p>所以源码的备份十分必要，否则源代码一旦丢失那就完了。</p><h3 id="本地备份-网盘备份">本地备份/网盘备份</h3><p>复制到另一台电脑、复制到另一个硬盘、复制到网盘上，这没啥好说的吧。</p><h3 id="Github备份">Github备份</h3><p>我个人来说的话，还是倾向于把代码文件放到存代码的地方…所以选择了这个。<br>当然，源代码是不可能开源的，所以<s>为了白嫖Github Page</s>我又新建了一个私有仓库，每次用Hexo部署完网站后再用Git推上私有仓库。</p><p>假如你不在意源代码开源，或者是已经用上了私有Github Page的话，这里有个更简单的办法：</p><ol><li>在你的仓库里新建分支，比如取名为<code>source</code>；</li><li>将本地<code>my_hexo_folder</code>链接到这条分支；</li><li>创建一个工作流<code>my_hexo_folder/.github/workflows/deploy.yml</code> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deploy</span>    <span class="comment"># 名字当然随便取</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span>    <span class="comment"># 对应源代码分支，假如有push就执行这条工作流</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">16.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;16.x&#x27;</span>    <span class="comment"># 这里选择与本地一致的版本比较方便</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">        <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">        <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">        <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">master</span>  <span class="comment"># 网站分支，默认都是master</span></span><br></pre></td></tr></table></figure></li><li>万事大吉，以后只需要<code>git push</code>上去source分支，Github就会自动帮咱生成到master分支，然后网页就更新了。</li></ol><blockquote><p>对于自购域名的情况或许也能也利用workflows，咱还不会，咱就不谈了。</p></blockquote><h2 id="网站更新">网站更新</h2><p>简而言之，以后网站的更新大致走这么个流程就好：</p><ol><li>同步源代码</li><li>进行你想做的更新</li><li>无论如何，先在本地部署并观察一遍 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: my_hexo_folder</span></span><br><span class="line">$ hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li><li>如果使用Github工作流，则直接推上去，完事；否则手动部署 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd: my_hexo_folder</span></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></li><li>同步源代码</li></ol><blockquote><p>写在后面：<s>总算写完第一篇了，写文章真累md</s></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在最最最前面</title>
      <link href="/2021/12/01/about-me/"/>
      <url>/2021/12/01/about-me/</url>
      
        <content type="html"><![CDATA[<h1>我</h1><p>一个平平无奇的学生党<br>间歇式努力，DDL式高效，兴趣式自觉<br>稍微懂点数学，稍微懂点计算机，稍微懂点杂七杂八的小工具<br><s>但是大部分时候都懒得分享</s></p><h1>你</h1><p>这个站欢迎一切来客，随缘进行交流探讨，哦对了，转载的时候还请标明出处~</p><h1>这个站</h1><p>创站最大的原因是因为好玩，其次是想有一个自己的小仓库，可以随便扔点什么进来。<br>这个站不为了成为什么知识库、资源站或是博客，不为了与人分享。所以你可能会发现有些看起来像教程的文章根本不够详细，因为那仅仅是我为了提醒自己所做的笔记罢了，如果这也能帮到你，那倒也不错。<br>我可能会写写知识总结，写写配置笔记，甚至写写随想和一切乱七八糟的东西上来。<br>但总而言之，目前还是个心血来潮、自娱自乐、空空如也的小地方罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
